<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Swift面试题]]></title>
      <url>http://yoursite.com/2016/11/12/Swift%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[Swift学习笔记]]></title>
      <url>http://yoursite.com/2016/11/04/Swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h3 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h3><p>Swift中 <code>let</code>定义常量,一经赋值不允许再修改<code>var</code>是变量,赋值之后仍然可以修改</p>
<p>Swift中 变量的声明用<code>var</code>常量的声明用<code>let</code>一般情况下都用<code>let</code>声明, 当需要重复赋值的时候再将<code>let</code>改为<code>var</code></p>
<p>Swift中 声明变量不用加类型,会根据=号后面的类型自动推倒出来前面变量的类型:<code>let a = 30</code> 那么 a的类型就是<code>Int</code>型</p>
<a id="more"></a>
<p>Swift中 任何不同类型的数据之间,不能直接进行运算,<code>let x = 10</code>,<code>let y = 10.5</code>这两个常量就不能一起运算,系统不会隐式类型转换,需要程序员强制类型转换<code>print(x + Int(y))</code> </p>
<p>Swift中 如果需要指定变量/常量的值,可以直接使用<code>let 变量名 : 类型 = 值</code>的方式<code>let a: int = 10</code>,在Swift中,很少使用直接指定类型,通常都是自动推到</p>
<p>Swift中 每句话的后面是不用加<code>;</code>的,如果一行中有多条语句,用<code>,</code>隔开</p>
<p>Swift中 执行一个方法直接调用方法名()<code>demo()</code>, <code>demo1()</code>, <code>demo2</code>,</p>
<p>Swift对代码进行了简化,<code>view.background = [UIColor redColor]</code>优化之后变为<code>view.background = UIColor.red()</code>这里的小括号的意思是执行代码 </p>
<p>Swift中 方法的声明为 func 方法名(形参列表) -&gt; 返回值{}</p>
<p>Swift中 可选项: (optional)可能有值,可能没值<code>let x:Optional = 10;</code>,<code>print(x)</code>输出结果为<code>Optional(10)</code>开发中一般都用<code>?</code>替换</p>
<p><code>let y :Int? = 10</code>,用来定义y是一个可选的,Int类型,可能没有值,也可能只有一个整数</p>
<p>Swift中 <code>!</code> 强行解包 – <code>从可选值中强行获取对应的非空值,如果真的是nil,系统就会崩溃</code>.崩溃信息:<code>unexpectedly found nil while unwrapping an Optional value</code>意思是:在解包的时候发现了nil值.我们必须为每一个<code>!</code>负责.<code>可选项在参与运算之前必须进行解包,因为nil不能参与运算!</code></p>
<p>Swift中 <code>?</code>用于定义 <code>!</code>用于解包,计算前 </p>
<p>Swift中 <code>var</code>的可选默认值为nil,<code>let</code>的可选默认值没有默认值</p>
<p>Swift中 类型转换用<code>as</code>,<code>值 as 类型</code>,<code>相当于OC中(XXXTableViewController *)[tableview dequeue...]</code><br>Swift中:</p>
<ul>
<li>字符串长度:返回指定编码的对应的字节数量<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> str = <span class="string">"hello world"</span>          </div><div class="line"><span class="built_in">print</span>(str.lengthOfBytes(using: .utf8))</div><div class="line">输出结果: <span class="number">11</span></div></pre></td></tr></table></figure></li>
<li>字符串长度:返回字符的个数<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">print</span>(str.characters.<span class="built_in">count</span>) </div><div class="line">输出结果 : <span class="number">13</span></div></pre></td></tr></table></figure></li>
<li>使用NSString中转: </li>
<li>字符串的拼接: <figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> name = <span class="string">"老王"</span></div><div class="line"><span class="keyword">let</span> age = <span class="number">18</span> - <span class="keyword">let</span> str = <span class="string">"<span class="subst">\(name)</span> <span class="subst">\(age)</span>"</span>               </div><div class="line"><span class="built_in">print</span>(str)</div><div class="line">输出结果: 老王<span class="number">18</span></div></pre></td></tr></table></figure></li>
<li>字符串的子串:一般使用NSString作为中转,因为Swift取子串的方法一直在优化<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// NSString</span></div><div class="line"><span class="keyword">let</span> str = <span class="string">"今天天气真好"</span></div><div class="line"><span class="keyword">let</span> ocStr = str <span class="keyword">as</span> <span class="type">NSString</span></div><div class="line"><span class="keyword">let</span> s1 = ocStr.substring(with: <span class="type">NSMakeRange</span>(<span class="number">2</span>, <span class="number">3</span>))</div><div class="line"><span class="built_in">print</span>(s1)</div><div class="line">输出结果:天气真</div><div class="line"></div><div class="line"><span class="comment">// String 的3.0方法</span></div><div class="line"><span class="keyword">let</span> s2 = str.substring(from: <span class="string">"今天"</span>.endIndex)</div><div class="line"><span class="built_in">print</span>(s2)</div><div class="line">输出结果: 天气真好</div></pre></td></tr></table></figure>
</li>
</ul>
<p>Swift中 数组的定义<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这里因为类型推倒的原因数组a的类型是String</span></div><div class="line"><span class="keyword">let</span> a = [<span class="string">"小明"</span>, <span class="string">"小红"</span>, <span class="string">"小芳"</span>]</div><div class="line"><span class="comment">// 这里因为类型推到的原因,数组b的类型是Int</span></div><div class="line"><span class="keyword">let</span> b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line"><span class="comment">// 数组中可以混合类型,但是应用场景并不多</span></div><div class="line"><span class="comment">// 结构体混合需要包装结构体</span></div></pre></td></tr></table></figure></p>
<p>Swift中 数组的定义<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> a1:[<span class="type">String</span>] = [<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>]</div><div class="line"><span class="keyword">let</span> a2:[<span class="type">Any</span>] = [<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="number">3</span>, <span class="type">UITableView</span>()]</div><div class="line"><span class="keyword">let</span> a3:<span class="type">NSArray</span> =  [<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="type">UILabel</span>()]</div><div class="line"><span class="keyword">let</span> a4:<span class="type">NSMutableArray</span> =  [<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>]</div></pre></td></tr></table></figure></p>
<p>Swift中 遍历数组的几种方式<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 数组的遍历</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo7</span><span class="params">()</span></span>  &#123;</div><div class="line"><span class="keyword">let</span> a = [<span class="string">"小明"</span>, <span class="string">"小红"</span>, <span class="string">"小芳"</span>];</div><div class="line"></div><div class="line"><span class="comment">// 第一种遍历 :  按照下标遍历</span></div><div class="line"><span class="keyword">for</span> temp <span class="keyword">in</span> <span class="number">0</span>..&lt;a.<span class="built_in">count</span> &#123;</div><div class="line"><span class="built_in">print</span>(a[temp])</div><div class="line">&#125;</div><div class="line"><span class="built_in">print</span>(<span class="string">"我是分割线------"</span>)</div><div class="line"></div><div class="line"><span class="comment">// 第二种遍历: for in 遍历</span></div><div class="line"><span class="keyword">for</span> temp <span class="keyword">in</span> a &#123;</div><div class="line"><span class="built_in">print</span>(temp)</div><div class="line">&#125;</div><div class="line"><span class="built_in">print</span>(<span class="string">"我是分割线------"</span>)</div><div class="line"></div><div class="line"><span class="comment">// 第三种遍历: 同时遍历下标和元素</span></div><div class="line"><span class="keyword">for</span> temp <span class="keyword">in</span> a.enumerated() &#123;</div><div class="line"><span class="built_in">print</span>(temp.offset, temp.element)</div><div class="line">&#125;</div><div class="line"><span class="built_in">print</span>(<span class="string">"我是分割线------"</span>)</div><div class="line"></div><div class="line"><span class="comment">// 第四种遍历: 遍历下标和内容</span></div><div class="line"><span class="keyword">for</span> (a, a1) <span class="keyword">in</span> a.enumerated() &#123;</div><div class="line"><span class="built_in">print</span>(a1, a)</div><div class="line">&#125;</div><div class="line"><span class="built_in">print</span>(<span class="string">"我是分割线------"</span>)</div><div class="line"></div><div class="line"><span class="comment">// 第五种遍历: 反序遍历</span></div><div class="line"><span class="keyword">for</span> temp <span class="keyword">in</span> a.reversed() &#123;</div><div class="line"><span class="built_in">print</span>(temp)</div><div class="line">&#125;</div><div class="line"><span class="built_in">print</span>(<span class="string">"我是分割线------"</span>)</div><div class="line"></div><div class="line"><span class="comment">// 第六种遍历: 反序遍历下标 元素</span></div><div class="line"><span class="comment">// 这种是错误的遍历 这种是元素反转,下标不反转</span></div><div class="line"><span class="keyword">for</span> temp <span class="keyword">in</span> a.reversed().enumerated() &#123;</div><div class="line"><span class="built_in">print</span>(temp)</div><div class="line">&#125;</div><div class="line"><span class="comment">//</span></div><div class="line"><span class="keyword">for</span> temp <span class="keyword">in</span> a.enumerated().reversed() &#123;</div><div class="line"><span class="built_in">print</span>(temp)</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure><br>Swift中 数组的增/删/改</p>
<ul>
<li>数组元素的添加<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>]</div><div class="line"></div><div class="line">a.append(<span class="string">"老张"</span>)    <span class="comment">// 添加元素,默认添加到末尾</span></div><div class="line"></div><div class="line">a.insert(<span class="string">"0"</span>, at: <span class="number">0</span>)    <span class="comment">// 插入元素,按照指定的位置插入</span></div><div class="line"></div></pre></td></tr></table></figure></li>
<li><p>数组元素的删除</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line">a.remove(at: <span class="number">0</span>)    <span class="comment">// 指定删除元素</span></div><div class="line"></div><div class="line">a.removeLast(<span class="number">2</span>)    <span class="comment">// 删除从后数开始2个元素</span></div><div class="line"></div><div class="line"><span class="comment">// 删除最后一个/第一个</span></div><div class="line">a.removeFirst()</div><div class="line">a.removeLast()</div><div class="line"></div><div class="line">a.removeAll(keepingCapacity: <span class="literal">true</span>)    <span class="comment">// 删除全部元素,并保留空间</span></div><div class="line"></div><div class="line">a.removeAll()     <span class="comment">// 删除所有</span></div><div class="line"></div></pre></td></tr></table></figure>   
</li>
<li><p>数组元素的修改</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a[<span class="number">0</span>] = <span class="string">"老王"</span>   <span class="comment">// 通过下标修改元素</span></div><div class="line"><span class="comment">// 将数组2~3的范围用指定数组替代</span></div><div class="line">a[<span class="number">2</span>...<span class="number">3</span>] = [<span class="string">"呵呵"</span>, <span class="string">"哈哈"</span>, <span class="string">"嘿嘿"</span>, <span class="string">"嘻嘻"</span>, <span class="string">"呼呼"</span>, <span class="string">"..."</span>]</div></pre></td></tr></table></figure>
</li>
</ul>
<p>Swift中 数组的合并<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [<span class="number">2</span><span class="string">"2"</span>,<span class="string">"3"</span>] <span class="keyword">as</span> [<span class="type">Any</span>]</div><div class="line"><span class="keyword">let</span> b: [<span class="type">Any</span>] = [<span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span>]</div><div class="line"></div><div class="line">a += b</div><div class="line"><span class="built_in">print</span>(a)</div><div class="line"></div><div class="line">输出结果: [<span class="number">2</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span>]</div></pre></td></tr></table></figure><br>Swift中 字典的定义<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// [key : value]</span></div><div class="line"><span class="keyword">let</span> dict = [<span class="string">"name"</span> : <span class="string">"laowang"</span>]</div><div class="line"></div><div class="line"><span class="comment">// 定义字典的数组</span></div><div class="line"><span class="keyword">let</span> a: [<span class="type">Dictionary</span>&lt;<span class="type">String</span>, <span class="type">Any</span>&gt;] = [</div><div class="line">[<span class="string">"name"</span> : <span class="string">"laowang"</span>, <span class="string">"age"</span> : <span class="number">18</span>],</div><div class="line">[<span class="string">"name"</span> : <span class="string">"laozhang"</span>, <span class="string">"age"</span> : <span class="number">20</span></div><div class="line">]</div><div class="line"></div><div class="line"><span class="keyword">let</span> dict: [<span class="type">String</span> : <span class="type">Any</span>] = [<span class="string">"name"</span> : <span class="string">"laowang"</span>, <span class="string">"age"</span> : <span class="number">19</span>]</div></pre></td></tr></table></figure><br>Swift中 字典的增删改<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dict[<span class="string">"height"</span>] = <span class="number">20</span>    <span class="comment">// 如果KEY存在 就是修改,如果KEY不存在就是新增</span></div></pre></td></tr></table></figure><br>Swift中 字典的合并<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> dict1: [<span class="type">String</span> : <span class="type">Any</span>] = [<span class="string">"name"</span> : <span class="string">"laowang"</span>, <span class="string">"height"</span> : <span class="number">18</span>, <span class="string">"title"</span> : <span class="string">"hehe"</span>]</div><div class="line"><span class="keyword">let</span> dict2: [<span class="type">String</span> : <span class="type">Any</span>] = [<span class="string">"name"</span> : <span class="number">18</span>, <span class="string">"love"</span> : <span class="string">"love"</span>]</div><div class="line"></div><div class="line"><span class="keyword">for</span> temp <span class="keyword">in</span> dict2 &#123;</div><div class="line">dict1[temp.key] = temp.value</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 如果KEY存在则替换,如果KEY不存在则新增</span></div><div class="line"></div><div class="line">输出结果: [<span class="string">"name"</span>: <span class="number">18</span>, <span class="string">"height"</span>: <span class="number">18</span>, <span class="string">"title"</span>: <span class="string">"hehe"</span>, <span class="string">"love"</span>: <span class="string">"love"</span>]</div></pre></td></tr></table></figure><br>Swift中 字典的遍历<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> dict: [<span class="type">String</span> : <span class="type">Any</span>] = [<span class="string">"name"</span> : <span class="string">"laowang"</span>, <span class="string">"age"</span> : <span class="number">18</span>]</div><div class="line"></div><div class="line"><span class="keyword">for</span> temp <span class="keyword">in</span> dict &#123;</div><div class="line"><span class="built_in">print</span>(temp)</div><div class="line"><span class="built_in">print</span>(temp.value, temp.key)</div><div class="line"><span class="built_in">print</span>(<span class="string">"<span class="subst">\(temp.key)</span> --- <span class="subst">\(temp.value)</span>"</span>)</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span> (key, value) <span class="keyword">in</span> dict &#123;</div><div class="line"><span class="built_in">print</span>(key, value)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<h3 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h3><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><ul>
<li>Swift中 函数的定义格式:<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span><span class="params">(形参<span class="number">1</span> ,形参<span class="number">2</span> )</span></span> -&gt; 返回值&#123;代码块&#125; </div></pre></td></tr></table></figure></li>
<li>Swift中 各个版本之间的调用:<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span><span class="params">(X: Int, Y: Int)</span></span>&#123;&#125;</div><div class="line"><span class="type">Swift1</span>.<span class="number">0</span>: fun(<span class="number">10</span>, <span class="number">20</span>)    <span class="comment">// 所有形参都会省略</span></div><div class="line"><span class="type">Swift2</span>.<span class="number">0</span>: fun(<span class="number">10</span>, <span class="type">Y</span>: <span class="number">20</span>)    <span class="comment">// 第一个形参省略</span></div><div class="line"><span class="type">Swift3</span>.<span class="number">0</span>: fun(x: <span class="number">10</span>, <span class="type">Y</span>: <span class="number">20</span>) <span class="comment">// 所有形参都不省略</span></div></pre></td></tr></table></figure></li>
<li>外部参数:给每个形参起一个别名,提高可读性<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">fun(num1 <span class="type">X</span>: <span class="type">Int</span>, num2 <span class="type">Y</span>:<span class="type">Int</span>)&#123;&#125;</div><div class="line">调用时: fun(num1: <span class="number">10</span>, num2: <span class="number">20</span>)</div></pre></td></tr></table></figure></li>
<li>外部参数如果使用<code>_</code>, 在调用时会忽略参数名<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">fun(<span class="number">_</span> <span class="type">X</span>: <span class="type">Int</span>, <span class="number">_</span> <span class="type">Y</span>: <span class="type">Int</span>)&#123;&#125;</div><div class="line">调用时:fun(<span class="number">10</span>, <span class="number">20</span>)</div></pre></td></tr></table></figure></li>
<li>Swift中 <code>_</code>就是可以忽略必须用但是不需要的地方比如:<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">10</span>&#123;</div><div class="line"><span class="built_in">print</span>(<span class="string">"呵呵"</span>)</div><div class="line">&#125;</div><div class="line">输出结果会打印<span class="number">10</span>次呵呵,但是i并没有用到,所以我们可以把i替换为<span class="number">_</span></div><div class="line"><span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">10</span>&#123;</div><div class="line"><span class="built_in">print</span>(<span class="string">"呵呵"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></li>
<li>默认值(OC不具备的)<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">fun(<span class="type">X</span>: <span class="type">Int</span> = <span class="number">10</span>, <span class="type">Y</span>: <span class="type">Int</span> = <span class="number">20</span>) -&gt; <span class="type">Int</span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="type">X</span> + <span class="type">Y</span></div><div class="line">&#125;</div><div class="line">调用时: </div><div class="line"><span class="number">1</span>.fun()</div><div class="line"><span class="number">2</span>.fun(<span class="type">X</span>: <span class="number">10</span>, <span class="type">Y</span>: <span class="number">21</span>)</div><div class="line">输出结果:</div><div class="line"><span class="built_in">print</span>(fun())</div><div class="line">结果: <span class="number">30</span></div><div class="line"><span class="built_in">print</span>(fun(<span class="type">X</span>: <span class="type">Int</span>, <span class="type">Y</span>: <span class="type">Int</span>))</div><div class="line">结果: <span class="number">31</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>结论:<br>当我们调用有默认值的函数时,如果不给函数的参数赋值,那么函数就会使用默认的值运算;如果给参数赋值<br>那么函数就会使用赋值后的值运算而不会使用默认值;如果不给第一个参数赋值,那么函数就会用第一个参数<br>的默认值与第二个参数运算;如果不给第二个参数赋值,那么函数就会用第一个参数的值与第二个参数的默认<br>值进行运算</p>
<p>一句话概括: 通过给参数设置默认值,在调用的时候,可以任意组合参数,如果有不指定的参数,则使用该参数的默认值运算</p>
<ul>
<li>Swift中 函数无返回值的三种情况: 主要用在闭包,在阅读第三框架代码时保证能看懂</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fun()&#123;&#125;</div><div class="line">fun() -&gt; ()&#123;&#125;    <span class="comment">// 最标准的写法  </span></div><div class="line">fun() -&gt; <span class="type">Void</span>&#123;&#125;</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">前面执行</th>
<th style="text-align:center">输出</th>
<th style="text-align:center">目标</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">fun()</td>
<td style="text-align:center">-&gt;</td>
<td style="text-align:center">{}</td>
</tr>
</tbody>
</table>
<h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h4><ul>
<li>可变参数的两种写法<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1. 直接写一个或多个参数</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">sun5</span> <span class="params">(a: Int...)</span></span> -&gt; (<span class="type">Int</span>)&#123;</div><div class="line"><span class="keyword">var</span> temp = <span class="number">0</span></div><div class="line"><span class="keyword">for</span> value <span class="keyword">in</span> a &#123;</div><div class="line">temp += value</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> temp</div><div class="line">&#125;</div><div class="line"></div><div class="line">sun5(a: <span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>)</div><div class="line"><span class="comment">// 2. 将参数以数组的形式传入</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">sun6</span> <span class="params">(a: [Int])</span></span> -&gt; (<span class="type">Int</span>)&#123;</div><div class="line"><span class="keyword">var</span> temp = <span class="number">0</span></div><div class="line"><span class="keyword">for</span> value <span class="keyword">in</span> a &#123;</div><div class="line">temp += value</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> temp</div><div class="line">&#125;</div><div class="line">sun6(a: [<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>])</div></pre></td></tr></table></figure></li>
<li>默认情况下,函数里面的参数,是一个常量,无法修改,如果想修改,通过传入变量的地址,并修改</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">sun6(a: [<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>])</div><div class="line"></div><div class="line"><span class="comment">// a = 10 , b = 20, 调用这个函数 a = 20 b = 10</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">sun7</span><span class="params">( aaa: <span class="keyword">inout</span> Int, bbb: <span class="keyword">inout</span> Int)</span></span> -&gt; ()&#123;</div><div class="line"><span class="keyword">let</span> temp = aaa</div><div class="line">aaa = bbb</div><div class="line">bbb = temp</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> aaa = <span class="number">1</span></div><div class="line"><span class="keyword">var</span> bbb = <span class="number">2</span></div><div class="line">sun7(aaa: &amp;aaa, bbb: &amp;bbb)</div><div class="line">aaa = <span class="number">2</span></div><div class="line">bbb = <span class="number">1</span></div></pre></td></tr></table></figure>
<ul>
<li>函数的类型<ul>
<li>函数作为参数: <figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 函数作为参数</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">sun</span><span class="params">(a: Int, b: Int)</span></span> -&gt; (<span class="type">Int</span>)&#123;</div><div class="line"><span class="keyword">return</span> a + b          <span class="comment">// 60</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">sun1</span><span class="params">(a: Int, b:Int, method:<span class="params">(Int, Int)</span></span></span> -&gt; (<span class="type">Int</span>)) -&gt; ()&#123;</div><div class="line">method(a, b)          <span class="comment">// 60</span></div><div class="line">&#125;</div><div class="line">sun1(a: <span class="number">30</span>, b: <span class="number">30</span>, method: sun)</div><div class="line">    </div></pre></td></tr></table></figure></li>
<li>函数作为返回值</li>
</ul>
</li>
</ul>
<h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><ul>
<li>枚举: 枚举定义了一组值,一组相关类型的值,可以在代码中以安全的方式来使用这些值</li>
<li>枚举的定义:<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 定义枚举</span></div><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">type0</span></span>&#123;</div><div class="line"><span class="keyword">case</span> type1</div><div class="line"><span class="keyword">case</span> type2</div><div class="line"><span class="keyword">case</span> type3</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 定义有原始值的枚举,原始值的类型可以是任意类型</span></div><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">type1</span>: <span class="title">Int</span></span>&#123;</div><div class="line"><span class="keyword">case</span> type1 = <span class="number">0</span></div><div class="line"><span class="keyword">case</span> type2 = <span class="number">1</span></div><div class="line"><span class="keyword">case</span> type3 = <span class="number">2</span></div><div class="line">&#125;</div><div class="line"> </div></pre></td></tr></table></figure></li>
<li>枚举的使用<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 可以通过枚举名.枚举值使用,也可以通过美剧名.枚举值来获得该枚举值的原始值</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">test1</span><span class="params">(type: type1)</span></span> -&gt; ()&#123;</div><div class="line"><span class="keyword">if</span> type == type1.type1 &#123;</div><div class="line"><span class="built_in">print</span>(type1.type1.rawValue)</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> type == type1.type2 &#123;</div><div class="line"><span class="built_in">print</span>(type1.type2.rawValue)</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> type == type1.type3 &#123;</div><div class="line"><span class="built_in">print</span>(type1.type3.rawValue)</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">test1(type: type1.type2)</div><div class="line">打印结果: <span class="number">1</span></div><div class="line"></div><div class="line"><span class="comment">// 通过原始值,返回枚举值</span></div><div class="line"><span class="built_in">print</span>(type1(rawValue: <span class="number">1</span>)!)</div><div class="line">打印结果: type2</div></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS10和Swift3.0那些事总结]]></title>
      <url>http://yoursite.com/2016/11/04/iOS10%E5%92%8CSwift3-0%E9%82%A3%E4%BA%9B%E4%BA%8B%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>Xcode8.0之后,如果图片名字是A.jpg<br>那么加载图片的代码就是<code>imageView.image = 图片名</code> 就OK </p>
<p>Xcode8.0之后比较好的更新:</p>
<ul>
<li>运行时检测: 在运行时可以帮我们检测整个自动布局里面的约束是否合法</li>
<li>内存图: </li>
<li>帮助文档:  </li>
</ul>
<p>Swift 中用闭包代替block<br>应用场景<br>1.控制器/自定义视图回调<br>2.异步任务回调</p>
<p>异步 GCD<br>OC的概念:将任务 block添加到队列,并且指定执行任务的函数(同步/异步)<br>Swift: 队列调度任务,以同步/异步方式执行</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[PCH文件使用指南]]></title>
      <url>http://yoursite.com/2016/10/27/PCH%E6%96%87%E4%BB%B6%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
      <content type="html"><![CDATA[<h3 id="非常简单的小贴士"><a href="#非常简单的小贴士" class="headerlink" title="非常简单的小贴士"></a>非常简单的小贴士</h3><p>下面直接上图…..<br><a id="more"></a><br><img src="/2016/10/27/PCH文件使用指南/1.png" alt="pch1"><br><img src="/2016/10/27/PCH文件使用指南/2.png" alt="pch2"></p>
<p>下面是对前面两张图片的解释</p>
<p>PCH文件使用方法:</p>
<ul>
<li>在目录下新建<code>PCH文件</code></li>
<li>进入到项目的<code>Build Settings</code> 搜索 <code>prefix Head</code></li>
<li>找到<code>Precompile Prefix Header</code>并且勾选为<code>YES</code></li>
<li>双击<code>Prefix Header</code>会弹出地址栏,将PCH文件的全路径拷贝过去</li>
<li>最后最好编译一下检查有没有出错</li>
</ul>
<p>用PCH,就是这么简单!!!</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS视图控制对象生命周期]]></title>
      <url>http://yoursite.com/2016/10/27/iOS%E8%A7%86%E5%9B%BE%E6%8E%A7%E5%88%B6%E5%AF%B9%E8%B1%A1%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      <content type="html"><![CDATA[<p>init- 初始化对象 </p>
<p>viewDidLoad- 加载视图完毕</p>
<p>viewWillAppear- UIViewController对象的视图即将加入到窗口时调用(即将显示)</p>
<a id="more"></a>
<p>viewDidAppear- UIViewController对象的视图已经加入到窗口上(完成显示时调用)</p>
<p>viewWillDisAppear- UIViewController对象的视图即将消失,被覆盖或是隐藏时调用</p>
<p>viewDidDisAppear- UIViewController对象的视图已经消失,被覆盖或是隐藏时调用</p>
<p>dealloc- 对象被销毁时调用</p>
<h3 id="下面先来看实例图片"><a href="#下面先来看实例图片" class="headerlink" title="下面先来看实例图片."></a>下面先来看实例图片.</h3><p><img src="/2016/10/27/iOS视图控制对象生命周期/1.gif" alt="gif"></p>
<p>这张gif的大致内容是这样的:</p>
<ul>
<li>在一个TabBarController里面有两个子控制器</li>
<li>两个控制器分别在这些方法调用的时候打印输出</li>
<li>当程序一启动的时候,会将两个控制器addChildViewController,并且将第一个childViewController的view添加到TabBarController显示View的View伤,所以one.view会打印viewDidLoad方法,</li>
<li>当点击TabBar,会显示two.view,而one.view会移除视野,所以<code>[sunTwo viewDidLoad]</code>,<code>[sunTwo viewWillAppear:]</code>,<code>[sunOne viewWillDisappear:]</code>,<code>[sunOne viewDidDisappear:]</code>,<code>[sunTwo viewDidAppear:]</code>会依次打印</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[mac下cocoapods完全使用教程]]></title>
      <url>http://yoursite.com/2016/10/20/mac%E4%B8%8Bcocoapods%E5%AE%8C%E5%85%A8%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h3 id="cocoapods出现在什么时候"><a href="#cocoapods出现在什么时候" class="headerlink" title="cocoapods出现在什么时候?"></a>cocoapods出现在什么时候?</h3><p>2014年</p>
<h3 id="cocoapods是干什么的"><a href="#cocoapods是干什么的" class="headerlink" title="cocoapods是干什么的?"></a>cocoapods是干什么的?</h3><p>管理第三方框架,是一个类库管理工具,当你的框架非常多,又必须下的时候,你就需要这样一款软件来帮你管理框架了.</p>
<a id="more"></a>
<h3 id="如何安装cocoapods"><a href="#如何安装cocoapods" class="headerlink" title="如何安装cocoapods??"></a>如何安装cocoapods??</h3><p>其实cocoapods的安装步骤非常简单,只需要仅仅几步就可以完成…</p>
<p>1.如果想使你的cocoapods安装过程不会出现太多错误,那么你需要先更新gem(gem太老,可能会出现问题)<br>可以用下面命令升级gem:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo gem update --system</div></pre></td></tr></table></figure></p>
<p>2.替换软件源,因为ruby的软件源是亚马逊云服务,可能会被墙,所以要更新ruby的源,用下面的代码将官方的ruby源替换成国内某宝的源:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">gem sources --remove https://rubygems.org/    </div><div class="line">gem sources -a https://reby.taobao.org/</div><div class="line">gem sources -l  // 查看源是否更变为某宝</div></pre></td></tr></table></figure></p>
<p>3.使用ruby的gem命令即可安装:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo gem install cocoapods</div><div class="line">pod setup</div></pre></td></tr></table></figure></p>
<p>经过以上三部曲cocoapods就安装到你的mac上啦</p>
<p>补充…<br>苹果系统升级 OS X EL Capitan 后安装改为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo gem install -n /usr/local/bin cocoapods</div><div class="line">pod setup</div></pre></td></tr></table></figure></p>
<h3 id="如何查找第三方库"><a href="#如何查找第三方库" class="headerlink" title="如何查找第三方库?"></a>如何查找第三方库?</h3><p>如果你不知道cocoapods管理的库中,是否有你想要的库,那么你可以通过<code>pod search 框架名</code>命令进行查找 比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod search AFNetworking</div></pre></td></tr></table></figure></p>
<p>就可以找到所有跟 AFNetworking 相关的库</p>
<h3 id="如何使用cocoapods"><a href="#如何使用cocoapods" class="headerlink" title="如何使用cocoapods?"></a>如何使用cocoapods?</h3><p>在工程文件下,生成podfile文件:描述需要使用哪些框架<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1. cd 进入到跟工程文件下同一级目录下</div><div class="line">2. touch(创建文件) touch podfile </div><div class="line">3. open podfile : 打开podfile进行描述(不会描述?请往下看) </div><div class="line">4. pod search : 搜索你想导入的框架并且告诉你如何描述</div><div class="line">5. pod install : 安装</div></pre></td></tr></table></figure></p>
<p>关于如何描述:我们以AFNetwworking为例:<br>当你使用 <code>pod search AFNetworking</code> 命令是这样子的:<br><img src="/2016/10/20/mac下cocoapods完全使用教程/2.png" alt="2"></p>
<p>将图片中<code>pod &#39;AFNetworking&#39;, &#39;~&gt; 3.1.0&#39;</code>这段代码复制到你的podfile文件中即可</p>
<p>当你按照提示敲到这里的时候,你回去看下项目目录结构,会出现一个新的名为<code>YourProjectName.xcworkspace</code>的文件,以后项目打开项目就需要通过这个文件打开了而不是<code>YourProjectName.xcodeproj</code>文件</p>
<h3 id="如何升级cocoapods"><a href="#如何升级cocoapods" class="headerlink" title="如何升级cocoapods?"></a>如何升级cocoapods?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo gem update -n /usr/local/bin --system</div></pre></td></tr></table></figure>
<p>输入这段代码即可升级你的cocoapods</p>
<p>补充…CocoaPods升级到1.0.1以上时，安装第三方库的时候会报如下错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">　　The dependency `AFNetworking (~&gt; 3.1.0)` is not used in any concrete target.</div></pre></td></tr></table></figure></p>
<p>则需要修改Podfile文件的内容,修改之前的Podfile文件的内容:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">platform:ios,&apos;7.0&apos;</div><div class="line">pod &apos;MJRefresh&apos;, &apos;~&gt; 3.1.0&apos;</div><div class="line">pod &apos;SDWebImage&apos;, &apos;~&gt; 3.7.6&apos;</div><div class="line">pod &apos;SVProgressHUD&apos;, &apos;~&gt; 2.0.3&apos;</div><div class="line">pod &apos;AFNetworking&apos;, &apos;~&gt; 3.1.0&apos;</div></pre></td></tr></table></figure></p>
<p>修改之后的Podfile文件的内容:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">platform:ios,&apos;7.0&apos;</div><div class="line">target &quot;MyProject&quot; do</div><div class="line">pod &apos;MJRefresh&apos;, &apos;~&gt; 3.1.0&apos;</div><div class="line">pod &apos;SDWebImage&apos;, &apos;~&gt; 3.7.6&apos;</div><div class="line">pod &apos;SVProgressHUD&apos;, &apos;~&gt; 2.0.3&apos;</div><div class="line">pod &apos;AFNetworking&apos;, &apos;~&gt; 3.1.0&apos;</div><div class="line">end</div></pre></td></tr></table></figure></p>
<p>在Podfile文件中需要明确指出使用第三方库的target,这里target后面跟的就是自己项目本身的Target;也就是项目中的tagrets中的那个项目名称.</p>
<h3 id="一些常用指令"><a href="#一些常用指令" class="headerlink" title="一些常用指令"></a>一些常用指令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Podfile.lock : 第一次使用pod install就会自动生成Podfile.lock,Podfile.lock描述当前加载第三方框架的版本号</div><div class="line">pod install : 根据Podfile.lock去加载依赖第三方库,第一次根据podfile去加载依赖库</div><div class="line">pod update : 更新第三方库的版本号,并且创建新的podfile.lock</div><div class="line">pod repo : 管理第三方库的索引</div><div class="line">pod install --no-repo-update : 不需要更新仓库的索引,直接加载原来记录的版本.开发中一般使用这个命令</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS面试题]]></title>
      <url>http://yoursite.com/2016/10/18/iOS%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      <content type="html"><![CDATA[<h3 id="从网上搜集的各种iOS面试题-会持续更新的"><a href="#从网上搜集的各种iOS面试题-会持续更新的" class="headerlink" title="从网上搜集的各种iOS面试题..会持续更新的"></a>从网上搜集的各种iOS面试题..会持续更新的</h3><hr>
<h2 id="1-简述OC中的内存管理机制"><a href="#1-简述OC中的内存管理机制" class="headerlink" title="1.简述OC中的内存管理机制"></a>1.简述OC中的内存管理机制</h2><p>OC的内存管理机制是自动引用技术,内存管理的原则是谁开辟谁释放,分为ARC和MRC,MRC就是需要程序员手动管理内存,ARC不需要程序员手动管理内存,系统会自行管理</p>
<a id="more"></a>
<h2 id="2-readwrite-readonly-assign-retain-copy-nonatomic-atomic-strong-weak属性的作用"><a href="#2-readwrite-readonly-assign-retain-copy-nonatomic-atomic-strong-weak属性的作用" class="headerlink" title="2.readwrite,readonly,assign,retain,copy,nonatomic,atomic,strong,weak属性的作用?"></a>2.readwrite,readonly,assign,retain,copy,nonatomic,atomic,strong,weak属性的作用?</h2><p>readWrite : 读写特性,可读可写<br>readonly : 只读,只有getter,没有setter<br>assign : 一般用于基本数据类型和ID类型<br>copy : 拷贝,一般用于NSString,分为深拷贝和浅拷贝,深拷贝拷贝的是对象,浅拷贝拷贝的是指针<br>nonatomic : 原子性,不考虑线程安全,优点是效率高<br>atomic : 原子性,优点是线程安全,缺点是效率低<br>strong : 强引用,和MRC下的retain一样,weak弱引用,类似MRC下的assgin,但是要注意的是strong和weak都是修饰对象类型的属性的,不能修饰基本数据类型,ARC下仍然使用assign修饰基本数据类型</p>
<h2 id="3-提升UITableView性能的几点建议"><a href="#3-提升UITableView性能的几点建议" class="headerlink" title="3.提升UITableView性能的几点建议"></a>3.提升UITableView性能的几点建议</h2><ul>
<li>cell高度计算</li>
<li>cells的重用</li>
<li>cell快速华东的时候不加载图片,停止滑动的时候加载图片</li>
<li>避免阻塞主线程</li>
<li>缓存下载的图片</li>
<li>不要过多使用XIB(如果可以的话使用storyboard)</li>
<li>使用CoreGraphics</li>
<li>透明度</li>
</ul>
<h2 id="4-线程同步和异步的区别"><a href="#4-线程同步和异步的区别" class="headerlink" title="4. 线程同步和异步的区别?"></a>4. 线程同步和异步的区别?</h2><p>同步 : 一个线程要等待上一个线程执行完之后才能执行,生活中的例子(上厕所).<br>异步 : 同时去做两个或者多个线程,比如边听歌边喝水.</p>
<h2 id="5-堆和栈的区别"><a href="#5-堆和栈的区别" class="headerlink" title="5,堆和栈的区别"></a>5,堆和栈的区别</h2><p>堆 : 一般由程序员分配释放,先进先出<br>栈 : 由编译器自动分配释放,存放函数的参数值,局部变量的值,先进后出<br>全局区(静态区) : 全局变量和静态变量,程序结束后由系统释放<br>文字常量区 : 常量字符串存放在这里,程序结束后由系统释放<br>程序代码区 : 存放函数体的二进制文件.</p>
<h2 id="6-iOS类是否可以多继承"><a href="#6-iOS类是否可以多继承" class="headerlink" title="6.iOS类是否可以多继承?"></a>6.iOS类是否可以多继承?</h2><p>不可以,可以通过delegate 和 protocol和类目来实现类似多继承.</p>
<h2 id="7-iOS本地存储都有哪几种方式-iOS如何实现复杂对象的存储"><a href="#7-iOS本地存储都有哪几种方式-iOS如何实现复杂对象的存储" class="headerlink" title="7.iOS本地存储都有哪几种方式?iOS如何实现复杂对象的存储?"></a>7.iOS本地存储都有哪几种方式?iOS如何实现复杂对象的存储?</h2><ul>
<li>write写入方式,永久保存在磁盘中,只支持NSString,NSData,NSArray.NSDictionary</li>
<li>NSKeydeArchiver(归档)采用归档的形式来保存数据,该数据对象需要遵守NSCoding协议</li>
<li>SQLite(FMDB) 注意FMDB不是数据库,而是一个SQLite管理框架</li>
<li>CoreData切记coredata不是数据库,他的存储和新思想是托管对象,只是咱们经常用的存储文件为SQLite还可以用XML,二进制等方式.</li>
</ul>
<h2 id="8-iOS的动态性"><a href="#8-iOS的动态性" class="headerlink" title="8.iOS的动态性"></a>8.iOS的动态性</h2><ul>
<li>动态类型 : 如id类型.实际上静态类型因为其固定性和可预见性而使用的更加广泛,静态类型是强类型,而动态类型属于罗类型.运行时决定接收者</li>
<li>动态绑定 : 让地阿妈在运行时判断需要调用什么方法,而不是在编译时</li>
<li>动态载入 : 让程序在运行时添加代码模块以及其他资源</li>
</ul>
<h2 id="9-什么是安全释放"><a href="#9-什么是安全释放" class="headerlink" title="9.什么是安全释放?"></a>9.什么是安全释放?</h2><p>在对象dealloc中release之后再把指针置为nill</p>
<h2 id="10-RunLoop是什么"><a href="#10-RunLoop是什么" class="headerlink" title="10.RunLoop是什么?"></a>10.RunLoop是什么?</h2><p>一个RunLoop就是一个事件处理的循环,用来不停的调度工作以及处理输入时间,使用runloop的目的是让你的线程在工作的时候忙于工作,没工作的时候处于休眠状态.主要是为了减少CPU武威的空转.每个线程都有RunLoop,主线程的RunLoop是默认开启的,手动开辟的子线程RunLoop是默认不开启的,如果需要开启,需要调用API<code>[[NSRunLoop currentRunloop] run]</code>开启,最常见的需要开启Runloop的是在子线程里面调用计时器(NSTimer),如果不开启runloop循环方法就不能正常执行.</p>
<h2 id="11-写一个标准宏MIN-这个宏输入两个参数并返回较小的一个"><a href="#11-写一个标准宏MIN-这个宏输入两个参数并返回较小的一个" class="headerlink" title="11.写一个标准宏MIN,这个宏输入两个参数并返回较小的一个?"></a>11.写一个标准宏MIN,这个宏输入两个参数并返回较小的一个?</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#define kMIN(X,Y)((X) &gt; (Y))?(Y) : (X))</div></pre></td></tr></table></figure>
<h2 id="12-简述应用程序按Home键进入后台时的生命周期-以及从后台回到前台时的生命周期"><a href="#12-简述应用程序按Home键进入后台时的生命周期-以及从后台回到前台时的生命周期" class="headerlink" title="12.简述应用程序按Home键进入后台时的生命周期,以及从后台回到前台时的生命周期?"></a>12.简述应用程序按Home键进入后台时的生命周期,以及从后台回到前台时的生命周期?</h2><ul>
<li><p>进入后台生命周期 :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (void)applicationWillResignActive:(UIApplication*)application;  </div><div class="line">- (void)applicationDidEnterBackground:(UIApplication*)application;</div></pre></td></tr></table></figure>
</li>
<li><p>回到前台生命周期 : </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (void)applicationWillEnterForeground:(UIApplication*)application;  </div><div class="line">- (void)applicationDidBecomActive:(UIApplication*)application;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="13-ViewController的loadView-viewDidLoad-viewWillAppear-dealloc、init分别是在什么时候调用的？在自定义ViewController的时候这几个函数里面应该做什么工作"><a href="#13-ViewController的loadView-viewDidLoad-viewWillAppear-dealloc、init分别是在什么时候调用的？在自定义ViewController的时候这几个函数里面应该做什么工作" class="headerlink" title="13.ViewController的loadView, viewDidLoad,viewWillAppear,dealloc、init分别是在什么时候调用的？在自定义ViewController的时候这几个函数里面应该做什么工作?"></a>13.ViewController的loadView, viewDidLoad,viewWillAppear,dealloc、init分别是在什么时候调用的？在自定义ViewController的时候这几个函数里面应该做什么工作?</h2><ul>
<li>loadView : 没有正在使用nib视图页面，子类将会创建自己的自定义视图层</li>
<li>viewDidLoad : 试图被加载后调用</li>
<li>viewWillAppear ： 试图即将出现的时候调用</li>
</ul>
<h2 id="14-简单说一下APP的启动过程"><a href="#14-简单说一下APP的启动过程" class="headerlink" title="14.简单说一下APP的启动过程"></a>14.简单说一下APP的启动过程</h2><p>程序启动分为两类:1.有storyboard 2.没有storyboard<br>有storyboard情况下:<br>1.main函数<br>2.UIApplicationMain</p>
<ul>
<li>创建UIApplication对象</li>
<li>创建UIApplication的delegate对象<br>3.根据Info.plist获得最主要storyboard的文件名,加载最主要的storyboard(有storyboard)</li>
<li>创建UIWindow</li>
<li>创建和设置UIWindow的rootViewController</li>
<li>显示窗口</li>
</ul>
<p>没有storyboard情况下:<br>1.main函数<br>2.UIApplicationMain</p>
<ul>
<li>创建UIApplication对象</li>
<li>创建UIApplication的delegate对象<br>3.delegate对象开始处理(监听)系统事件(没有storyboard)</li>
<li>程序启动完毕的时候, 就会调用代理的application:didFinishLaunchingWithOptions:方法</li>
<li>在application:didFinishLaunchingWithOptions:中创建UIWindow</li>
<li>创建和设置UIWindow的rootViewController</li>
<li>显示窗口<h2 id="15-引用程序的代理方法有哪些"><a href="#15-引用程序的代理方法有哪些" class="headerlink" title="15.引用程序的代理方法有哪些?"></a>15.引用程序的代理方法有哪些?</h2></li>
<li>程序加载完毕：application: didFinishLaunchingWithOptions:</li>
<li>程序获取焦点：applicationDidBecomeActive:</li>
<li>程序进入后台：applicationDidEnterBackground:</li>
<li>程序失去焦点：applicationWillResignActive:</li>
<li>程序从后台回到前台：applicationWillEnterForeground</li>
<li>内存警告，可能要终止程序：applicationDidReceiveMemoryWarning:</li>
<li>程序即将退出：applicationWillTerminate:</li>
</ul>
<p>##16.控制器的声明周期?</p>
<ul>
<li>loadView(加载控制器的view时调用) -&gt;</li>
<li>viewDidLoad(控制器的view加载完毕时调用) -&gt;</li>
<li>viewWillAppear(控制器的view即将显示时调用) -&gt;</li>
<li>viewDidAppear(控制器的view完全显示时调用) -&gt;</li>
<li>viewWillDisappear(控制器的view即将消失时调用) -&gt;</li>
<li>viewDidDisappear(控制器的view完全消失时调用) -&gt; </li>
<li>didReceiveMemoryWarning(控制器接收到从UIApplication传来的内存警告时调用,询问view是否可以被销毁(view不在window上就可以销毁)) -&gt;</li>
<li>viewWillUnload(控制器的view即将销毁时调用) -&gt;</li>
<li>销毁view(此时控制器的属性都没有被清理) -&gt;</li>
<li>viewDidUnload(控制器的view完全销毁时调用,清空控制器内不需要的属性) -&gt;</li>
<li>loadView(需要再次显示控制器是在调用) 往复循环</li>
</ul>
<h2 id="17-事件处理-如何寻找最合适的view"><a href="#17-事件处理-如何寻找最合适的view" class="headerlink" title="17.事件处理,如何寻找最合适的view?"></a>17.事件处理,如何寻找最合适的view?</h2><p>1.先判断自己能不能接受触摸事件,如果不能,交给自己的父控件处理事件 如果能<br>2.判断当前点在不在自己身上,如果不能,交给自己的父控件处理事件,如果在自己身上<br>3.从后往前遍历自己的子控件,遍历出每个子控件之后,重复前面的步骤<br>4.如果没有符合条件的子控件,那么它自己就是最合适的view</p>
<h2 id="18-事件的响应"><a href="#18-事件的响应" class="headerlink" title="18.事件的响应:"></a>18.事件的响应:</h2><p>当用户点击屏幕产生的一个触摸事件,经过一系列传递之后,会找到最合适的视图来处理这个事件<br>找到最合适的视图控件之后,就会调用控件的touchs方法来具体处理事件<br>这些touches方法的默认做法是将事件顺着响应者链条向上传递</p>
<p>什么是响应者链条:<br>多个响应者对象连接起来的链条</p>
<p>什么是响应者对象:<br>继承了 UIResponder对象我们称之为响应者对象,也就是能处理事件的对象</p>
<h2 id="19-事件传递的完整过程"><a href="#19-事件传递的完整过程" class="headerlink" title="19.事件传递的完整过程"></a>19.事件传递的完整过程</h2><ul>
<li>在产生一个事件时,系统会将该事件加入到一个由UIApplication管理的事件队列中,</li>
<li>UIApplication会从事件队列中取出最前面的事件,将它传递给先发送事件给应用程序的主窗口.</li>
<li>主窗口会调用hitTest方法寻找最适合的视图控件,找到后就会调用视图控件的touches方法来做具体的事情.</li>
<li>当调用touches方法,它的默认做法, 就会将事件顺着响应者链条往上传递，</li>
<li>传递给上一个响应者,接着就会调用上一个响应者的touches方法</li>
</ul>
<p>如何去寻找上一个响应者?<br>1.如果当前的View是控制器的View,那么控制器就是上一个响应者.<br>2.如果当前的View不是控制器的View,那么它的父控件就是上一个响应者.<br>3.在视图层次结构的最顶级视图，如果也不能处理收到的事件或消息，则其将事件或消息传递给window对象进行处理<br>4.如果window对象也不处理，则其将事件或消息传递给UIApplication对象<br>5.如果UIApplication也不能处理该事件或消息，则将其丢弃</p>
<p>—————————————-我是分割线—————————————–</p>
<h2 id="20-UIWindow和UIView和-CALayer-的联系和区别"><a href="#20-UIWindow和UIView和-CALayer-的联系和区别" class="headerlink" title="20.UIWindow和UIView和 CALayer 的联系和区别?"></a>20.UIWindow和UIView和 CALayer 的联系和区别?</h2><ul>
<li>UIView是视图的基类比,UIViewController是视图控制器的基类,UIResponder是表示一个可以在屏幕上响应触摸时间的对象</li>
<li>UIwindow是UIView的子类,UIwindow的主要作用:一是提供一个区域来显示UIView,二是将事件(event)的分发给UIView,一个应用基本上只有一个UIwindow</li>
<li>UIView和CAlayer的老祖宗都是NSObject,可见UIResponder是用来响应事件的,也就是UIView可以响应用户事件<br>CALayer 和 UIView 的区别</li>
<li>UIView的继承结构为:UIResponder:NSObject</li>
<li>CALayer的继承结构为:NSObject,可见,UIResponder是用来响应事件的,也就是UIView可以响应用户事件,CALayer直接从NSObject继承,因为缺少了UIResponder类,不能响应任何用户事件</li>
<li>所属框架:UIView是在UIKit.framework中定义的.UIKit主要是用来构建用户界面,并且是可以响应时间的,CALayer是在QuartCore.framework定义的.而且CALayer作为一个低级的,可以承载绘制内容的底层对象出现在该框架中.</li>
<li>UIView相比CAlayer最大的区别是UIView可以响应用户事件,而CALayer不可以,UIView侧重于对像是内容的管理,CALayer侧重于对内容的绘制,UIView是基于CALayer的高层封装</li>
<li>相似支持:<br>1.相似的树形<br>2.显示内容绘制方式<br>3.布局约束</li>
<li>总结一下就是: UIView是用来显示内容的,可以处理用户时间,CALayer是用来绘制内容的,对内容进行动画处理依赖与UIView来进行展示,不能处理用户事件<br>为啥有两套体系?<br>并不是两套体系UIView和CALayer是相互依赖关系,UIView依赖于CALayer提供的内容,CALayer依赖UIView提供的容器来显示绘制的内容.归根结底,CALayer是这一切的基础,如果没有CALayer,UIView自身也不会存在,UIView是一个特殊的CALayer实现.添加了响应事件的能力UIView本身,更像是一个CALayer的管理器,访问他的跟绘图和坐标有关的属性,例如frame,bounds等等,实际上内部都是在访问他所包含的CALayer的相关属性</li>
<li>UIView的layer树形在系统内部,被系统维护这三份copy<br>第一份,逻辑树,就是代码里可以操纵的,例如更改layer的属性等等就在这一份<br>第二份,动画树.这是一个中间层,系统正在这一层上更改属性,进行各种渲染操作<br>第三份,显示树,这棵树的内容是当前正被显示在屏幕上的内容.<br>这三棵树的逻辑结都是一样的,区别只有各自的属性</li>
</ul>
<p>UIView的主layer以外,对它的sublayer,也就是layer的属性进行更改,系统将自动进行动画生成<br>CALayer的坐标系系统和UIView有点不一样,他多了一个叫anchorPoint的属性,它使用CGPoint结构,但是值域是0~1,也就是按照比例来设置,这个点是各种图形变换的坐标原点,同事会更改layer的posititon的位置,它的缺省值是{0.5, .0.5}, 也就是在layer的中央<br>(一脸懵逼的一道题….)</p>
<h2 id="21-property都有哪些常见的字段"><a href="#21-property都有哪些常见的字段" class="headerlink" title="21.property都有哪些常见的字段?"></a>21.property都有哪些常见的字段?</h2><ul>
<li>strong</li>
<li>weak</li>
<li>assgin</li>
<li>copy</li>
<li>nomatic</li>
<li>readonly</li>
</ul>
<h2 id="22-strong-wek-assgin-copy-nomatic-readonly等的区别"><a href="#22-strong-wek-assgin-copy-nomatic-readonly等的区别" class="headerlink" title="22. strong, wek, assgin, copy, nomatic, readonly等的区别"></a>22. strong, wek, assgin, copy, nomatic, readonly等的区别</h2><ul>
<li>assign: 简单赋值,不更改索引计数对基础数据类</li>
<li>copy 简历一个索引计数为1的对象,然后释放旧对象,对NSString</li>
<li>retain: 释放旧的对象,将旧对象的值赋予输入对象,再提高输入对象的索引计数为1,对其他NSOBject和其子类</li>
<li>weak 和 strong的区别: weak和strong不同的是,当一个对象不再有strong类型的指针指向它的时候,他会被释放,即使还有weak型指针指向它,一旦最后一个strong型指针离去,这个对象将被释放,所有剩余的weak型指正都将被清楚</li>
<li>copy 于 retain:<br>1.copy其实是建立了一个相同的对象,而retain不是<br>2.copy是内容拷贝,retain是指针拷贝.<br>3.copy是内容拷贝,对于像NSString的确是这样,如果拷贝的是NSArray,这时只是copy了指向array中相对应元素的指针,这边是所谓的潜复制<br>atomic是Objc使用的一种线程保护技术,基本上来讲,是防止在写未完成的时候被另外一个线程读取,造成数据错误,而这种机制是号位系统资源的,所以在iPhone这种小型设备上,如果没有使用多线程间的通讯编程,那么nomatin是一个非常好的选择.</li>
</ul>
<h2 id="23-Array问题"><a href="#23-Array问题" class="headerlink" title="23.Array问题"></a>23.Array问题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 面试题: 如果初始化指定容量,可以避免插入数据时,重复分配空间,效率会高一点点</div><div class="line">NSMutableArray *array = [NSMutableArray arrayWithCapacity:10];</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Mac搭建Hexo博客]]></title>
      <url>http://yoursite.com/2015/10/17/Mac%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>技术大牛都有自己的博客,而且感觉非常漂亮.比QQ空间之类的好看多了.正好最近也想自己搭建个博客,记录下自己的学习经历吧,给自己留点回忆,同时整理下自己的思路.最重要的是大家看到这篇博文之后也可以搭建属于自己的博客了,所以,说干就干!</p>
<a id="more"></a>
<h1 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h1><p>1.基于Hexo和gethub pages搭建静态博客<br>2.主题分享</p>
<h1 id="基础准备"><a href="#基础准备" class="headerlink" title="基础准备"></a>基础准备</h1><h2 id="正式搭建博客-要想使用Hexo和github-pages搭建博客-需要以下环境"><a href="#正式搭建博客-要想使用Hexo和github-pages搭建博客-需要以下环境" class="headerlink" title="正式搭建博客!要想使用Hexo和github pages搭建博客,需要以下环境"></a>正式搭建博客!要想使用Hexo和github pages搭建博客,需要以下环境</h2><p>1.Github账号一枚 ,并创建一个指定名字的repo<br>2.Homebrew套件管理器,主要用来安装git和node.js<br>3.Git版本管理工具<br>4.node.js<br>5.配置SSH Key(可忽略)<br>6.安装Hexo<br>7.同步Hexo博客到github<br>这些东西都不熟悉没关系，下面都会详细介绍。</p>
<h2 id="注册Github账号并创建repo"><a href="#注册Github账号并创建repo" class="headerlink" title="注册Github账号并创建repo"></a>注册Github账号并创建repo</h2><p>因为博客是基于github pages的,也就是你的博客内容是托管在gethub pages 所以我们需要有一个github账号,并且创建一个publicrepo来存放你的博客 如果你还没有github账号,去<a href="https://github.com/join?source=header-home" target="_blank" rel="external">这里</a>申请一个就好了,申请步骤很简单记住创建public库 private是要收费的,我们用github主要就是拥抱开源.</p>
<p>申请完账号,登陆之后 就可以创建repo了 点击<code>New repository</code>:<img src="/2015/10/17/Mac搭建Hexo博客/1.png" alt="1"><br>会跳转到这个界面:<br><img src="/2015/10/17/Mac搭建Hexo博客/2.png" alt="2"> 需要注意的地方我已经做了标注,最需要注意的就是你创建的库的名字,必须是<code>username.github.io</code>等创建库的时候,把<code>username</code>换成你的用户名就可以了,点击<code>creat repository</code>就可以把仓库创建出来.</p>
<p>要想进一步深入了解github,可以阅读这些资料:</p>
<p><a href="https://github.com/tiimgreen/github-cheat-sheet/blob/master/README.zh-cn.md" target="_blank" rel="external">Github秘籍</a></p>
<p><a href="http://www.worldhello.net/gotgithub/" target="_blank" rel="external">GoGithub</a></p>
<p><a href="http://stormzhang.com/github/2016/06/19/learn-github-from-zero-summary/" target="_blank" rel="external">stormzhang 从0开始学习github系列</a></p>
<h2 id="安装Homebrew套件管理器"><a href="#安装Homebrew套件管理器" class="headerlink" title="安装Homebrew套件管理器"></a>安装Homebrew套件管理器</h2><p>我们安装Homebrew的目的是方便安装git和node.js 但是Homebrew需要你的mac安装Xcode,其实很多mac应用也需要Xcode,所以建议安装一下,appstore里就有.装完Xcode之后,剩下的步骤就特别简单了,打开mac terminal终端,输入以下命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</div></pre></td></tr></table></figure></p>
<p>就可以自动完成该工具的安装,如果这条命令失效了,可能是Homebrew更新了安装方式可以去<a href="http://brew.sh/index_zh-cn.html" target="_blank" rel="external">这里</a>查看最新安装命令以及Homebrew的简要介绍.Homebrew安装完成之后,安装get和node.js简直简单的不要不要的.</p>
<p>Homebrew一些常用命令可以阅读以下资料:</p>
<p><a href="http://www.qetee.com/exp/other/homebrew/" target="_blank" rel="external">Homebrew常用命令</a></p>
<h3 id="安装Git版本管理工具"><a href="#安装Git版本管理工具" class="headerlink" title="安装Git版本管理工具"></a>安装Git版本管理工具</h3><p>Git是一个强大的版本管理工具，Github的版本管理就是基于Git的，现在svn基本过时了，使用Git进行版本管理才是王道。安装完Homebrew之后，安装Git几乎零成本，还是在terminal终端，输入以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install git</div></pre></td></tr></table></figure></p>
<p>然后等一段时间就OK了,Homebrew会自动帮你完成下载安装.</p>
<p>Git使用教程,可以参考以下资料:</p>
<p><a href="http://stormzhang.com/github/2016/06/19/learn-github-from-zero-summary/" target="_blank" rel="external">stormzhang Git快速应用系列</a></p>
<p><a href="http://git.oschina.net/progit/" target="_blank" rel="external">Pro Git中文版</a></p>
<h3 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h3><p>Hexo是基于node.js的,所以要让Hexo运行,node.js环境是必不可少的,使用Homebrew安装node.js也特别简单,在treminal终端输入如下命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install node</div></pre></td></tr></table></figure></p>
<p>然后等着Homebrew帮你完成下载安装就可以了,舒爽到爆炸!安装完node.js就可以使用常见的npm命令了 </p>
<h3 id="配置SSH-Key"><a href="#配置SSH-Key" class="headerlink" title="配置SSH Key"></a>配置SSH Key</h3><p>这一步可以忽略，配置SSH key与否，并不影响博客的搭建和使用，只是配置了之后，更新博客方便一点，不用每次都输用户名和密码.</p>
<h3 id="检查本机上是否存在SSH-key"><a href="#检查本机上是否存在SSH-key" class="headerlink" title="检查本机上是否存在SSH key"></a>检查本机上是否存在SSH key</h3><p>打开终端,输入如下命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd .ssh</div><div class="line">ls -la</div></pre></td></tr></table></figure></p>
<p>检查终端输出的文件列表中是否已经存在id_rsa.pub 或 id_dsa.pub 文件，如果文件已经存在，那么你可以跳过步骤2，直接进入步骤3.</p>
<h3 id="创建一个SSH-Key"><a href="#创建一个SSH-Key" class="headerlink" title="创建一个SSH Key"></a>创建一个SSH Key</h3><p>在终端输入以下命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh-keygen -t rsa -C &quot;your_email@example.com&quot;</div></pre></td></tr></table></figure></p>
<p>回车,接着会提示你让你输入文件名,直接回车会创建使用默认文件名的文件（推荐使用默认文件名);然后会提示你输入两次密码（输入密码之后没有反馈,显示还是空白,但是你确实已经输入了）,当然密码也可以不输,直接回车,如果这里没有输入密码,以后提交博客更新的时候就不需要输入密码了.</p>
<h3 id="添加SSH-Key到github"><a href="#添加SSH-Key到github" class="headerlink" title="添加SSH Key到github"></a>添加SSH Key到github</h3><p>经过第二步，如果你没有指定文件名（也就是使用的默认文件名），那么你的.ssh文件夹下，应该有一个id_rsa.pub文件了，打开该文件，复制里面的文本。然后登陆github，点击右上角头像右边的三角图标，点击Settings，然后在左边菜单栏点击SSH and GPG keys，点击new ssh key，title 随便填一个，在key 栏填入你复制的内容，点击add ssh key，就可以添加一个ssh key了，如下图：<img src="/2015/10/17/Mac搭建Hexo博客/3.png" alt="3"></p>
<h3 id="验证SSH-Key是否配置成功"><a href="#验证SSH-Key是否配置成功" class="headerlink" title="验证SSH Key是否配置成功"></a>验证SSH Key是否配置成功</h3><p>在终端输入以下命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh -T git@github.com</div></pre></td></tr></table></figure></p>
<p>如果你创建的key没有设密码的话,直接一顿回车,直到最后提示你<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Hi yourusername! You&apos;ve successfully authenticated, but GitHub does not provide shell access.</div></pre></td></tr></table></figure></p>
<p>说明你的SSH Key添加成功了.如果过程中提示你preimission deny相关错误,就在命令前加上<code>sudo</code>然后执行命令的时候输入你的appleid密码应该就可以了.<code>sudo</code>用来说明用管理员权限运行.</p>
<p>以上简略介绍了怎么配置SSH Key,如果想知道命令里面参数的含义,或者配置过程不顺利的话,可以看<a href="http://www.cnblogs.com/ayseeing/p/3572582.html" target="_blank" rel="external">这里</a>的详细教程.</p>
<h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>经过以上的步骤,安装Hexo就可以使用npm命令了,而Hexo安装就是使用npm,在终端输入以下命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g hexo</div></pre></td></tr></table></figure></p>
<p>然后等一会儿,hexo会自动完成下载安装,安装完成之后,在你喜欢的位置随意创建一个文件夹,这个文件夹以后就是你存放本地博客的地方了,通过<code>cd filepath</code>(filepath替换成你创建的文件夹目录)命令,进入到你创建的文件夹目录,然后执行以下命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hexo init</div><div class="line">npm install</div></pre></td></tr></table></figure></p>
<p>这样Hexo会在该文件夹创建本地博客所需要的一切资源.这样本地博客就搭建好了,输入以下命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hexo g  // 全拼是：hexo generate，可以简写成 hexo g</div><div class="line">hexo s  // 全拼是：hexo server，可以简写成 hexo s</div></pre></td></tr></table></figure></p>
<p>这样就开启了一个本地博客服务器,打开浏览器没在地址栏输入<code>localhost:4000</code>,就可以查看本地博客了,hexo默认生成了一篇hello world的博客.注意,以上hexo开头的命令,执行目录必须是你创建的博客文件夹目录.</p>
<h3 id="同步Hexo博客到Github"><a href="#同步Hexo博客到Github" class="headerlink" title="同步Hexo博客到Github"></a>同步Hexo博客到Github</h3><p>现在你已经可以在本机查看你的博客了,但是要想让别人通过网络可以查看你的博客,还需要一步,那就是将你的博客发布到github仓库.在terminal终端,将当前目录切换到你的本地博客目录,执行以下命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install hexo-deployer-git --save</div></pre></td></tr></table></figure></p>
<p>安装完成之后,打开本地博客目录的<code>_config.yml</code>文件,编辑其中的deploy节点:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">type: git</div><div class="line">repo: git@github.com:yourusername/youusername.github.io.git</div><div class="line">branch: master</div></pre></td></tr></table></figure></p>
<p>将上面<code>yourusername</code>替换成你的github用户名,你也可以去你开始的时候创建的名为<code>yourusername.guthub.io</code>的仓库直接复制完成的地址,如下图:<img src="/2015/10/17/Mac搭建Hexo博客/4.png" alt="4"><br>当前复制出来的值,就是通过SSH方式clone的地址,配置完成后,以后提交博客更新不用输入用户名和密码(如果你SSH Key没有设置密码的话);点击上图右上角<code>User Https</code>,复制出来的clone地址也可以配置到repo,但是这样,提交更新的时候,就需要输入用户名密码了</p>
<p>保存配置之后,在本地博客目录执行以下命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">hexo clean  // clean本地项目，防止缓存</div><div class="line">hexo g      // 根据你编辑的md格式的博客，生成静态网页</div><div class="line">hexo d      // 将本地博客发布到github</div></pre></td></tr></table></figure></p>
<p><code>hexo g</code>,<code>hexo d</code>这两条命令可以组合成<code>hexo d -g</code>来写,效果是一样的.<br>然后在浏览器地址栏输入<code>yourusername.github.io</code>就可以访问你的博客了,别人也可以通过这个地址访问你的博客</p>
<p>如果想了解Hexo常用命令可以点击<a href="https://hexo.io/zh-cn/docs/commands.html" target="_blank" rel="external">这里</a></p>
<p><a href="https://segmentfault.com/a/1190000002632530" target="_blank" rel="external">这里是从网上搜集的Hexo常用指令笔记</a></p>
<p>以上就是搭建Mac的全过程了 </p>
<p>下面分享一些比较好用,好看的Hexo主题.</p>
<p><a href="https://hexo.io/themes/" target="_blank" rel="external">(一)</a><br><a href="https://www.zhihu.com/question/24422335" target="_blank" rel="external">(二)</a></p>
]]></content>
    </entry>
    
  
  
</search>
